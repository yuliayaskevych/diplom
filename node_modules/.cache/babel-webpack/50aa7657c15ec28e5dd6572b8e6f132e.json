{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, NgZone, NgModule } from '@angular/core';\nimport { asyncScheduler, Observable, of, merge } from 'rxjs';\nimport { map, share, switchMap, scan, distinctUntilChanged, withLatestFrom, skipWhile } from 'rxjs/operators';\nimport * as i1 from '@angular/fire';\nimport { ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory, ɵfirebaseAppFactory, ɵlogAuthEmulatorError, ɵfetchInstance, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire';\nimport 'firebase/database';\nimport * as i2 from '@angular/fire/auth';\nimport { USE_EMULATOR as USE_EMULATOR$1 } from '@angular/fire/auth';\nimport firebase from 'firebase/app';\nimport * as ɵngcc0 from '@angular/core';\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isFirebaseDataSnapshot(value) {\n  return typeof value.exportVal === 'function';\n}\n\nfunction isNil(obj) {\n  return obj === undefined || obj === null;\n}\n\nfunction isFirebaseRef(value) {\n  return typeof value.set === 'function';\n}\n/**\n * Returns a database reference given a Firebase App and an\n * absolute or relative path.\n * @param database - Firebase Database\n * @param pathRef - Database path, relative or absolute\n */\n\n\nfunction getRef(database, pathRef) {\n  // if a db ref was passed in, just return it\n  return isFirebaseRef(pathRef) ? pathRef : database.ref(pathRef);\n}\n\nfunction checkOperationCases(item, cases) {\n  if (isString(item)) {\n    return cases.stringCase();\n  } else if (isFirebaseRef(item)) {\n    return cases.firebaseCase();\n  } else if (isFirebaseDataSnapshot(item)) {\n    return cases.snapshotCase();\n  }\n\n  throw new Error(`Expects a string, snapshot, or reference. Got: ${typeof item}`);\n}\n/**\n * Create an observable from a Database Reference or Database Query.\n * @param ref Database Reference\n * @param event Listen event type ('value', 'added', 'changed', 'removed', 'moved')\n * @param listenType 'on' or 'once'\n * @param scheduler - Rxjs scheduler\n */\n\n\nfunction fromRef(ref, event, listenType = 'on', scheduler = asyncScheduler) {\n  return new Observable(subscriber => {\n    let fn = null;\n    fn = ref[listenType](event, (snapshot, prevKey) => {\n      scheduler.schedule(() => {\n        subscriber.next({\n          snapshot,\n          prevKey\n        });\n      });\n\n      if (listenType === 'once') {\n        scheduler.schedule(() => subscriber.complete());\n      }\n    }, err => {\n      scheduler.schedule(() => subscriber.error(err));\n    });\n\n    if (listenType === 'on') {\n      return {\n        unsubscribe() {\n          if (fn != null) {\n            ref.off(event, fn);\n          }\n        }\n\n      };\n    } else {\n      return {\n        unsubscribe() {}\n\n      };\n    }\n  }).pipe(map(payload => {\n    const {\n      snapshot,\n      prevKey\n    } = payload;\n    let key = null;\n\n    if (snapshot.exists()) {\n      key = snapshot.key;\n    }\n\n    return {\n      type: event,\n      payload: snapshot,\n      prevKey,\n      key\n    };\n  }), share());\n}\n\nfunction listChanges(ref, events, scheduler) {\n  return fromRef(ref, 'value', 'once', scheduler).pipe(switchMap(snapshotAction => {\n    const childEvent$ = [of(snapshotAction)];\n    events.forEach(event => childEvent$.push(fromRef(ref, event, 'on', scheduler)));\n    return merge(...childEvent$).pipe(scan(buildView, []));\n  }), distinctUntilChanged());\n}\n\nfunction positionFor(changes, key) {\n  const len = changes.length;\n\n  for (let i = 0; i < len; i++) {\n    if (changes[i].payload.key === key) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction positionAfter(changes, prevKey) {\n  if (isNil(prevKey)) {\n    return 0;\n  } else {\n    const i = positionFor(changes, prevKey);\n\n    if (i === -1) {\n      return changes.length;\n    } else {\n      return i + 1;\n    }\n  }\n}\n\nfunction buildView(current, action) {\n  const {\n    payload,\n    prevKey,\n    key\n  } = action;\n  const currentKeyPosition = positionFor(current, key);\n  const afterPreviousKeyPosition = positionAfter(current, prevKey);\n\n  switch (action.type) {\n    case 'value':\n      if (action.payload && action.payload.exists()) {\n        let prevKey = null;\n        action.payload.forEach(payload => {\n          const action = {\n            payload,\n            type: 'value',\n            prevKey,\n            key: payload.key\n          };\n          prevKey = payload.key;\n          current = [...current, action];\n          return false;\n        });\n      }\n\n      return current;\n\n    case 'child_added':\n      if (currentKeyPosition > -1) {\n        // check that the previouskey is what we expect, else reorder\n        const previous = current[currentKeyPosition - 1];\n\n        if ((previous && previous.key || null) !== prevKey) {\n          current = current.filter(x => x.payload.key !== payload.key);\n          current.splice(afterPreviousKeyPosition, 0, action);\n        }\n      } else if (prevKey == null) {\n        return [action, ...current];\n      } else {\n        current = current.slice();\n        current.splice(afterPreviousKeyPosition, 0, action);\n      }\n\n      return current;\n\n    case 'child_removed':\n      return current.filter(x => x.payload.key !== payload.key);\n\n    case 'child_changed':\n      return current.map(x => x.payload.key === key ? action : x);\n\n    case 'child_moved':\n      if (currentKeyPosition > -1) {\n        const data = current.splice(currentKeyPosition, 1)[0];\n        current = current.slice();\n        current.splice(afterPreviousKeyPosition, 0, data);\n        return current;\n      }\n\n      return current;\n    // default will also remove null results\n\n    default:\n      return current;\n  }\n}\n\nfunction validateEventsArray(events) {\n  if (isNil(events) || events.length === 0) {\n    events = ['child_added', 'child_removed', 'child_changed', 'child_moved'];\n  }\n\n  return events;\n}\n\nfunction snapshotChanges(query, events, scheduler) {\n  events = validateEventsArray(events);\n  return listChanges(query, events, scheduler);\n}\n\nfunction stateChanges(query, events, scheduler) {\n  events = validateEventsArray(events);\n  const childEvent$ = events.map(event => fromRef(query, event, 'on', scheduler));\n  return merge(...childEvent$);\n}\n\nfunction auditTrail(query, events, scheduler) {\n  const auditTrail$ = stateChanges(query, events).pipe(scan((current, action) => [...current, action], []));\n  return waitForLoaded(query, auditTrail$, scheduler);\n}\n\nfunction loadedData(query, scheduler) {\n  // Create an observable of loaded values to retrieve the\n  // known dataset. This will allow us to know what key to\n  // emit the \"whole\" array at when listening for child events.\n  return fromRef(query, 'value', 'on', scheduler).pipe(map(data => {\n    // Store the last key in the data set\n    let lastKeyToLoad; // Loop through loaded dataset to find the last key\n\n    data.payload.forEach(child => {\n      lastKeyToLoad = child.key;\n      return false;\n    }); // return data set and the current last key loaded\n\n    return {\n      data,\n      lastKeyToLoad\n    };\n  }));\n}\n\nfunction waitForLoaded(query, action$, scheduler) {\n  const loaded$ = loadedData(query, scheduler);\n  return loaded$.pipe(withLatestFrom(action$), // Get the latest values from the \"loaded\" and \"child\" datasets\n  // We can use both datasets to form an array of the latest values.\n  map(([loaded, actions]) => {\n    // Store the last key in the data set\n    const lastKeyToLoad = loaded.lastKeyToLoad; // Store all child keys loaded at this point\n\n    const loadedKeys = actions.map(snap => snap.key);\n    return {\n      actions,\n      lastKeyToLoad,\n      loadedKeys\n    };\n  }), // This is the magical part, only emit when the last load key\n  // in the dataset has been loaded by a child event. At this point\n  // we can assume the dataset is \"whole\".\n  skipWhile(meta => meta.loadedKeys.indexOf(meta.lastKeyToLoad) === -1), // Pluck off the meta data because the user only cares\n  // to iterate through the snapshots\n  map(meta => meta.actions));\n}\n\nfunction createDataOperationMethod(ref, operation) {\n  return function dataOperation(item, value) {\n    return checkOperationCases(item, {\n      stringCase: () => ref.child(item)[operation](value),\n      firebaseCase: () => item[operation](value),\n      snapshotCase: () => item.ref[operation](value)\n    });\n  };\n} // TODO(davideast): Find out why TS thinks this returns firebase.Primise\n// instead of Promise.\n\n\nfunction createRemoveMethod(ref) {\n  return function remove(item) {\n    if (!item) {\n      return ref.remove();\n    }\n\n    return checkOperationCases(item, {\n      stringCase: () => ref.child(item).remove(),\n      firebaseCase: () => item.remove(),\n      snapshotCase: () => item.ref.remove()\n    });\n  };\n}\n\nfunction createListReference(query, afDatabase) {\n  const outsideAngularScheduler = afDatabase.schedulers.outsideAngular;\n  const refInZone = afDatabase.schedulers.ngZone.run(() => query.ref);\n  return {\n    query,\n    update: createDataOperationMethod(refInZone, 'update'),\n    set: createDataOperationMethod(refInZone, 'set'),\n    push: data => refInZone.push(data),\n    remove: createRemoveMethod(refInZone),\n\n    snapshotChanges(events) {\n      return snapshotChanges(query, events, outsideAngularScheduler).pipe(afDatabase.keepUnstableUntilFirst);\n    },\n\n    stateChanges(events) {\n      return stateChanges(query, events, outsideAngularScheduler).pipe(afDatabase.keepUnstableUntilFirst);\n    },\n\n    auditTrail(events) {\n      return auditTrail(query, events, outsideAngularScheduler).pipe(afDatabase.keepUnstableUntilFirst);\n    },\n\n    valueChanges(events, options) {\n      const snapshotChanges$ = snapshotChanges(query, events, outsideAngularScheduler);\n      return snapshotChanges$.pipe(map(actions => actions.map(a => {\n        if (options && options.idField) {\n          return Object.assign(Object.assign({}, a.payload.val()), {\n            [options.idField]: a.key\n          });\n        } else {\n          return a.payload.val();\n        }\n      })), afDatabase.keepUnstableUntilFirst);\n    }\n\n  };\n}\n\nfunction createObjectSnapshotChanges(query, scheduler) {\n  return function snapshotChanges() {\n    return fromRef(query, 'value', 'on', scheduler);\n  };\n}\n\nfunction createObjectReference(query, afDatabase) {\n  return {\n    query,\n\n    snapshotChanges() {\n      return createObjectSnapshotChanges(query, afDatabase.schedulers.outsideAngular)().pipe(afDatabase.keepUnstableUntilFirst);\n    },\n\n    update(data) {\n      return query.ref.update(data);\n    },\n\n    set(data) {\n      return query.ref.set(data);\n    },\n\n    remove() {\n      return query.ref.remove();\n    },\n\n    valueChanges() {\n      const snapshotChanges$ = createObjectSnapshotChanges(query, afDatabase.schedulers.outsideAngular)();\n      return snapshotChanges$.pipe(afDatabase.keepUnstableUntilFirst, map(action => action.payload.exists() ? action.payload.val() : null));\n    }\n\n  };\n}\n\nconst URL = /*#__PURE__*/new InjectionToken('angularfire2.realtimeDatabaseURL');\nconst USE_EMULATOR = /*#__PURE__*/new InjectionToken('angularfire2.database.use-emulator');\nlet AngularFireDatabase = /*#__PURE__*/(() => {\n  class AngularFireDatabase {\n    constructor(options, nameOrConfig, databaseURL, // tslint:disable-next-line:ban-types\n    platformId, zone, _useEmulator, // tuple isn't working here\n    useAuthEmulator) {\n      this.schedulers = new ɵAngularFireSchedulers(zone);\n      this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers);\n      const useEmulator = _useEmulator;\n      const app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n\n      if (!firebase.auth && useAuthEmulator) {\n        ɵlogAuthEmulatorError();\n      }\n\n      this.database = ɵfetchInstance(`${app.name}.database.${databaseURL}`, 'AngularFireDatabase', app, () => {\n        const database = zone.runOutsideAngular(() => app.database(databaseURL || undefined));\n\n        if (useEmulator) {\n          database.useEmulator(...useEmulator);\n        }\n\n        return database;\n      }, [useEmulator]);\n    }\n\n    list(pathOrRef, queryFn) {\n      const ref = this.schedulers.ngZone.runOutsideAngular(() => getRef(this.database, pathOrRef));\n      let query = ref;\n\n      if (queryFn) {\n        query = queryFn(ref);\n      }\n\n      return createListReference(query, this);\n    }\n\n    object(pathOrRef) {\n      const ref = this.schedulers.ngZone.runOutsideAngular(() => getRef(this.database, pathOrRef));\n      return createObjectReference(ref, this);\n    }\n\n    createPushId() {\n      const ref = this.schedulers.ngZone.runOutsideAngular(() => this.database.ref());\n      return ref.push().key;\n    }\n\n  }\n\n  AngularFireDatabase.ɵfac = function AngularFireDatabase_Factory(t) {\n    return new (t || AngularFireDatabase)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(URL, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(USE_EMULATOR, 8), ɵngcc0.ɵɵinject(USE_EMULATOR$1, 8));\n  };\n  /** @nocollapse */\n\n\n  AngularFireDatabase.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function AngularFireDatabase_Factory() {\n      return new AngularFireDatabase(i0.ɵɵinject(i1.FIREBASE_OPTIONS), i0.ɵɵinject(i1.FIREBASE_APP_NAME, 8), i0.ɵɵinject(URL, 8), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(i2.USE_EMULATOR, 8));\n    },\n    token: AngularFireDatabase,\n    providedIn: \"any\"\n  });\n  /** @nocollapse */\n\n  return AngularFireDatabase;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AngularFireDatabaseModule = /*#__PURE__*/(() => {\n  class AngularFireDatabaseModule {}\n\n  AngularFireDatabaseModule.ɵfac = function AngularFireDatabaseModule_Factory(t) {\n    return new (t || AngularFireDatabaseModule)();\n  };\n\n  AngularFireDatabaseModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AngularFireDatabaseModule\n  });\n  AngularFireDatabaseModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [AngularFireDatabase]\n  });\n  return AngularFireDatabaseModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularFireDatabase, AngularFireDatabaseModule, URL, USE_EMULATOR, auditTrail, createListReference, fromRef, listChanges, snapshotChanges, stateChanges }; //# sourceMappingURL=angular-fire-database.js.map","map":null,"metadata":{},"sourceType":"module"}